import glob
import os
from pathlib import Path

import numpy as np
import xarray as xr

import gnl.xcalc
from gnl.xarray import coarsen

data_root = "/home/disk/eos4/nbren12/Data/SAM6.10.9/JOBS/Run-0c31ce4c6763d8ec2abccafe6bde2fa0bed8124d/data"

grav = 9.81
cp = 1004
Lc = 2.5104e6
rho0 = 1.19

@wrap_xarray_calculation
def liquid_water_temperature(t, qn, qp):
    """This is an approximate calculation neglecting ice and snow
    """

    sl = t + grav/cp * t.z - Lc/cp * (qp + qn)/1000.0
    sl.attrs['units'] = 'K'
    return sl

@wrap_xarray_calculation
def total_water(qv, qn):
    qt =  qv + qn
    qt.attrs['units'] = 'g/kg'
    return qt


def get_dz(z):
    zext = np.hstack((0,  z,  2.0*z[-1] - 1.0*z[-2]))
    zw = .5 * (zext[1:] + zext[:-1])
    dz = zw[1:] - zw[:-1]

    return xr.DataArray(dz, z.coords)

def layer_mass(rho):
    dz = get_dz(rho.z)
    return rho*dz


# Rules for Linking data
def data_files():
    for file in glob.glob(f"{data_root}/**/*.nc", recursive=True):
        yield file[len(data_root)+1:]


def link_files(files):
    for file in files:
        path = Path(file)
        path.parent.mkdir(exist_ok=True)
        os.system(f"ln -s {data_root}/{file} {path}")


rule link_data:
    output: *data_files()
    run:
        link_files(output)

rule coarse_grain:
    input: "{f}.nc"
    output: "A{m,[0-9]+}/{f}.nc"
    run:
        m = int(wildcards.m)

        xr.open_dataarray(input[0], chunks={'time': 50})\
            .pipe(lambda x: coarsen(x, x=m))\
            .to_netcdf(output[0])

rule liquid_water:
    input: T="A64/3d/TABS.nc",
           qn="A64/3d/QN.nc",
           qp="A64/3d/QP.nc",
           qv="A64/3d/QV.nc",
           u="A64/3d/U.nc",
           w="A64/3d/W.nc"
    output: sl="calc/sl.nc", qt="calc/qt.nc", u="calc/U.nc", w="calc/W.nc"
    run:
        sl = liquid_water_temperature(input.T, input.qn, input.qp)
        sl.to_dataset(name="sl").to_netcdf(output.sl)

        qt = total_water(input.qv, input.qn)\
               .to_dataset(name="qt")\
               .to_netcdf(output.qt)

        # need to link files for computing total derivatives
        shell("ln -s  ../{input.u} {output.u}")
        shell("ln -s  ../{input.w} {output.w}")

rule apparent_heating:
    input: dsl="M/calc/sl.nc", stat="stat.nc"
    output: "calc/q1.nc"
    run:
        dsl = xr.open_dataset(input.dsl).sl
        ttend = xr.open_dataset(input.stat).TTEND.reindex_like(dsl, method='nearest')
        # need to translate from K/s to K/d
        q1 = dsl * 86400
        q1.attrs['units'] = 'K/d'
        d = q1.to_dataset(name="q1")
        # include tendency
        d['tend'] = ttend

        d.to_netcdf(output[0])

rule apparent_drying:
    input: dqt="M/calc/qt.nc", stat="stat.nc"
    output: "calc/q2.nc"
    run:
        dqt = xr.open_dataset(input.dqt).qt
        tend = xr.open_dataset(input.stat).QTEND.reindex_like(dqt, method='nearest')
        scal  = 86400/1000 * Lc/cp
        # need to translate from g/kg/s to K/day
        q2 = -(dqt - tend/86400.0)*scal
        q2.attrs['units'] = 'K/d'
        q2.attrs['long_name'] = "Apparent drying"
        q2.to_dataset(name="q2").to_netcdf(output[0])

rule maximum_cov_analysis:
    input: q1="calc/q1.nc", q2="calc/q2.nc",
           sl="calc/sl.nc", qt="calc/qt.nc",
           weight="w.nc"
    output: "calc/mca.nc"
    script: "mca.py"

rule partial_least_squares:
    input: files=["calc/q1.nc", "calc/q2.nc", "calc/qt.nc", "calc/sl.nc"],
           weight="w.nc"
    params: input_vars=["qt", "sl"], pred_vars=["q1", "q2"],
            feature_dims=["z"], sample_dims=["time", "x"]
    output: "calc/pls.nc", pkl="calc/pls.pkl"
    script: "pls.py"

rule weights:
    input: "stat.nc"
    output: "w.nc"
    run:
        stats = xr.open_dataset(input[0])
        dz = get_dz(stats.z)
        rho = stats.RHO[-1]
        w = layer_mass(rho)
        w = np.sqrt(w/w.sum('z'))
        w.to_netcdf(output[0])

rule weight_ngaqua:
    input: "/home/disk/eos8/pnaren/ML/codes/forlaptop/data.nc"
    output: w="ngaqua/w.nc", p="ngaqua/p.nc"
    run:
        D  = xr.open_dataset(input[0])
        D['z'] = D['zkm']
        w = layer_mass(D.rho)
        w = np.sqrt(w/w.sum('z'))
        w.to_netcdf(output.w)

        # output pressure
        xr.open_dataset(input[0]).p.to_dataset(name="p")\
          .to_netcdf(output.p)


rule partial_least_squares_ngaqua:
    input: files=["/home/disk/eos8/pnaren/ML/codes/forlaptop/data.nc"],
           weight= "ngaqua/w.nc"
    output: "ngaqua/pls.nc", pkl="ngaqua/pls.pkl"
    params: input_vars=["qt", "sl"], pred_vars=["q1c", "q2"],
            feature_dims=["z"], sample_dims=["time", "x"]
    script: "pls.py"

rule report:
    input: "ngaqua/w.nc", "ngaqua/p.nc", "calc/pls.pkl", "calc/mca.nc", "A64/2d/Prec.nc"
    output: "Report for August 8, 2017.html"
    shell: 'jupyter nbconvert --execute ../"Report for August 8, 2017.ipynb"'



def xopen(name, nt=20):
    return xr.open_dataset(name, chunks=dict(time=nt))\
             .apply(lambda x: x.squeeze())

def xopena(name, nt=20):
    return xr.open_dataarray(name, chunks={'time': nt})

def wrap_xarray_calculation(f):
    def fun(*args, **kwargs):
        new_args = []
        for a in args:
            if isinstance(a, str):
                new_args.append(xopena(a))
            else:
                new_args.append(a)

        return f(*new_args, **kwargs)

    return fun


def calc_der(f, dim):
    bdy = {'x': 'periodic', 'z':'periodic', 'time':'periodic'}
    return f.centderiv(dim, boundary=bdy[dim])


@wrap_xarray_calculation
def calc_matder(dt, dx, dz, u, w):
    return (dt + dx*u + dz*w)

wildcard_constraints:
    dim="(x|time|z)", # used for arguments to operators
    field="[^/]+"    # no path seperators


rule derivative:
    input: f="{f}.nc"
    output:"D{dim}/{f}.nc"
    run:
        dim = wildcards.dim
        f = xopen(input[0])\
            .apply(lambda x: calc_der(x, dim) if dim in x.dims else x)

        if dim == 'time':
            f /= 86400
        f.to_netcdf(output[0])


rule material_derivative:
    input: u="{d}/U.nc", w="{d}/W.nc",
           dx="Dx/{d}/{field}.nc",
           dz="Dz/{d}/{field}.nc",
           dt="Dtime/{d}/{field}.nc"
    output: "M/{d}/{field}.nc"
    run:
        out = calc_matder(input.dt, input.dx, input.dz, input.u, input.w)
        out.to_dataset(name=wildcards.field).to_netcdf(output[0])

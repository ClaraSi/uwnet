import glob
import os
from pathlib import Path

import numpy as np
import xarray as xr

import gnl.xcalc
from gnl.xarray import coarsen
from gnl.xarray import map_overlap
import dask.array as da
from dask.array.core import atop
from dask import delayed

data_root = "/home/disk/eos4/nbren12/Data/SAM6.10.9/JOBS/Run-0c31ce4c6763d8ec2abccafe6bde2fa0bed8124d/data"

grav = 9.81
cp = 1004
Lc = 2.5104e6
rho0 = 1.19

def wrap_xarray_calculation(f):
    def fun(*args, **kwargs):
        new_args = []
        for a in args:
            if isinstance(a, str):
                new_args.append(xopena(a))
            else:
                new_args.append(a)

        return f(*new_args, **kwargs)

    return fun

@wrap_xarray_calculation
def liquid_water_temperature(t, qn, qp):
    """This is an approximate calculation neglecting ice and snow
    """

    sl = t + grav/cp * t.z - Lc/cp * (qp + qn)/1000.0
    sl.attrs['units'] = 'K'
    return sl

@wrap_xarray_calculation
def total_water(qv, qn):
    qt =  qv + qn
    qt.attrs['units'] = 'g/kg'
    return qt


def get_dz(z):
    zext = np.hstack((0,  z,  2.0*z[-1] - 1.0*z[-2]))
    zw = .5 * (zext[1:] + zext[:-1])
    dz = zw[1:] - zw[:-1]

    return xr.DataArray(dz, z.coords)

def layer_mass(rho):
    dz = get_dz(rho.z)
    return rho*dz


# Rules for Linking data
def data_files():
    for file in glob.glob(f"{data_root}/**/*.nc", recursive=True):
        yield file[len(data_root)+1:]


def link_files(files):
    for file in files:
        path = Path(file)
        path.parent.mkdir(exist_ok=True)
        os.system(f"ln -s {data_root}/{file} {path}")


rule link_data:
    output: *data_files()
    run:
        link_files(output)

rule coarse_grain:
    input: "{f}.nc"
    output: "A{m,[0-9]+}/{f}.nc"
    threads: 8
    run:
        m = int(wildcards.m)

        xr.open_dataarray(input[0], chunks={'time': 50})\
            .pipe(lambda x: coarsen(x, x=m))\
            .to_netcdf(output[0])

rule liquid_water:
    input: T="A64/3d/TABS.nc",
           qn="A64/3d/QN.nc",
           qp="A64/3d/QP.nc",
           qv="A64/3d/QV.nc",
           u="A64/3d/U.nc",
           w="A64/3d/W.nc"
    output: sl="calc/sl.nc", qt="calc/qt.nc", u="calc/U.nc", w="calc/W.nc"
    run:
        sl = liquid_water_temperature(input.T, input.qn, input.qp)
        sl.to_dataset(name="sl").to_netcdf(output.sl)

        qt = total_water(input.qv, input.qn)\
               .to_dataset(name="qt")\
               .to_netcdf(output.qt)

        # need to link files for computing total derivatives
        shell("ln -s  ../{input.u} {output.u}")
        shell("ln -s  ../{input.w} {output.w}")

rule apparent_heating:
    input: sl="calc/sl.nc", stat="stat.nc"
    output: "calc/q1.nc"
    run:
        dsl = xr.open_dataset(input.dsl).sl
        ttend = xr.open_dataset(input.stat).TTEND.reindex_like(dsl, method='nearest')
        # need to translate from K/s to K/d
        q1 = dsl * 86400
        q1.attrs['units'] = 'K/d'
        d = q1.to_dataset(name="q1")
        # include tendency
        d['tend'] = ttend

        d.to_netcdf(output[0])

rule apparent_drying:
    input: dqt="M/calc/qt.nc", stat="stat.nc"
    output: "calc/q2.nc"
    run:
        dqt = xr.open_dataset(input.dqt).qt
        tend = xr.open_dataset(input.stat).QTEND.reindex_like(dqt, method='nearest')
        scal  = 86400/1000 * Lc/cp
        # need to translate from g/kg/s to K/day
        q2 = -(dqt - tend/86400.0)*scal
        q2.attrs['units'] = 'K/d'
        q2.attrs['long_name'] = "Apparent drying"
        q2.to_dataset(name="q2").to_netcdf(output[0])


rule weights:
    input: "stat.nc"
    output: "w.nc"
    run:
        stats = xr.open_dataset(input[0])
        dz = get_dz(stats.z)
        rho = stats.RHO[-1]
        w = layer_mass(rho)
        w = np.sqrt(w/w.sum('z'))
        w.to_netcdf(output[0])

rule weight_ngaqua:
    input: "/home/disk/eos8/pnaren/ML/codes/forlaptop/data.nc"
    output: w="ngaqua/w.nc", p="ngaqua/p.nc"
    run:
        D  = xr.open_dataset(input[0])
        D['z'] = D['zkm']
        w = layer_mass(D.rho)
        w = np.sqrt(w/w.sum('z'))
        w.to_netcdf(output.w)

        # output pressure
        xr.open_dataset(input[0]).p.to_dataset(name="p")\
          .to_netcdf(output.p)

# rule report:
#     input: "ngaqua/w.nc", "ngaqua/p.nc", "calc/pls.pkl", "calc/mca.nc", "A64/2d/Prec.nc"
#     output: "Report for August 8, 2017.html"
#     shell: 'jupyter nbconvert --execute ../"Report for August 8, 2017.ipynb"'
# 


def xopen(name, nt=20):
    return xr.open_dataset(name, chunks=dict(time=nt))\
             .apply(lambda x: x.squeeze())

def xopena(name, nt=20):
    return xr.open_dataarray(name, chunks={'time': nt})



def calc_der(f, dim):
    bdy = {'x': 'periodic', 'z':'periodic', 'time':'periodic'}
    return f.centderiv(dim, boundary=bdy[dim])


@wrap_xarray_calculation
def calc_matder(dt, dx, dz, u, w):
    return (dt + dx*u + dz*w)

def centers_to_interface(zc):
    """Get centers of the cells bounded by z with padding on the right
    """
    # cell centered z
    zc  = np.hstack((-zc[0], zc))
    return (zc[1:] + zc[:-1])/2


def vertdiv(phi, w, rho):
    """Vertical advection divergence

    w is assumed to be on the vertical faces
    phi re at the cell centers.

    """

    phi = phi.transpose(*w.dims) # ensure data are tranposed correctly
    axis = phi.get_axis_num('z')

    # get vertical coordinate at cell centers
    zc = phi.z.values
    zw = centers_to_interface(zc)


    def fun(phi, w, rho):
        phi = phi.swapaxes(axis, -1)
        w = w.swapaxes(axis, -1)

        phiw = interp1d(zc, phi, axis=-1, fill_value='extrapolate')(zw)
        rhow = interp1d(zc, rho, axis=-1, fill_value='extrapolate')(zw)
        F = phiw * w * rhow
        out = (np.roll(F, -1, -1) - F)/(np.roll(zw, -1) - zw)/rho

        return out.swapaxes(axis, -1)

    tup4d = list(range(3))

    out_dask = atop(fun, tup4d,
                    phi.data, tup4d,
                    w.data, tup4d,
                    rho.data, (axis,),
                    dtype=phi.data.dtype)

    return xr.DataArray(out_dask, w.coords)

def xdiv(phi, u):
    
    xu = phi.x # value at x-faces
    phi = phi.transpose(*u.dims)
    axis = phi.get_axis_num('x')

    # Assumes the horizontal grid is equally spaced
    dx = float(xu[1]-xu[0])

    def myghost(phi):
        return da.ghost.ghost(phi.data, {axis: 1}, {axis: "periodic"})

    def fun(phi, u):
        phi = phi.swapaxes(axis, -1)
        u = u.swapaxes(axis, -1)

        phiu = (np.roll(phi, 1, -1) + phi)/2.0
        F = phiu * u
        out = (np.roll(F, -1, -1) - F)/dx

        return out.swapaxes(axis, -1)

    out_dask = atop(fun, phi.dims,
            myghost(phi), phi.dims,
            myghost(u), u.dims,
            dtype=phi.data.dtype)

    out_dask = da.ghost.trim_internal(out_dask, {axis:1})

    return xr.DataArray(out_dask, u.coords)
         


wildcard_constraints:
    dim="(x|time|z)", # used for arguments to operators
    field="[^/]+"    # no path seperators


rule derivative:
    input: f="{f}.nc"
    output:"Dx/{f}.nc"
    run:
        dim = wildcards.dim
        f = xopen(input[0])\
            .apply(lambda x: calc_der(x, 'x') if 'x' in x.dims else x)
        f.to_netcdf(output[0])

rule vertical_derivative:
    input: "{f}.nc"
    output: "Dz/{f}.nc"

rule vertical_advection:
    input: "{f}.nc", w="A64/3d/W.nc", stat="stat.nc"
    output: "zadv/{f}.nc"
    run:
        phi = xr.open_dataarray(input[0])
        w = xr.open_dataarray(input.w)
        rho = xr.open_dataset(input.stat).RHO[-1]

        vertdiv(phi, w, rho).to_netcdf(output[0])


rule horizontal_advection:
    input: "{f}.nc", u="A64/3d/U.nc"
    output: "xadv/{f}.nc"
    run:
        phi = xopena(input[0])
        u = xopena(input.u)

        xdiv(phi, u).to_netcdf(output[0])

rule total_advection:
    input: x="xadv/{f}.nc", z="zadv/{f}.nc"
    output: "adv/{f}.nc"
    run:
        (xopena(input.x) + xopena(input.z)).to_netcdf(output[0])

rule material_derivative:
    input: u="{d}/U.nc", w="{d}/W.nc",
           dx="Dx/{d}/{field}.nc",
           dz="Dz/{d}/{field}.nc",
           dt="Dtime/{d}/{field}.nc"
    output: "M/{d}/{field}.nc"
    run:
        out = calc_matder(input.dt, input.dx, input.dz, input.u, input.w)
        out.to_dataset(name=wildcards.field).to_netcdf(output[0])
